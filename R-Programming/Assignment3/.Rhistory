## TODO!  Need to sort and show the least alphabetical!
## Pull out the row that has the lowest value.
##data_min <- lapply(data_by_state_clean, min)
## Return hospital name in that state with lowest 30-day death
##data_lowest_value$Hospital.Name
## rate
}
source("rankhospital.R")
rankhospital("TX", "heart failure", 4)
rankhospital("TX", "heart failure", 4)
View(data_by_state_clean)
? nrow(data_by_state_clean)
nrow(data_by_state_clean)
? return
rankhospital <- function(state, outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## Return hospital name in that state with the given rank
## 30-day death rate
## Read outcome data
data_all <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Check that state is valid
## Logic for validity: if it is in the table.
data_by_state <- data_all[data_all$State == state, ]
if (nrow(data_by_state) == 0){
stop("invalid state")
}
## Check that outcome are valid, and get further subset.
column_number <- -1
if (outcome == "heart attack"){
column_number <- 11
}
else if (outcome == "heart failure"){
column_number <- 17
}
else if (outcome == "pneumonia"){
column_number <- 23
}
else{
stop("invalid outcome")
}
## data_by_state_and_outcome <- data_by_state[data_by_state[]]
## convert the right column to numbers.
data_by_state[, column_number] <- as.numeric(data_by_state[, column_number])
## Let's remove the NA's.
bad_rows <- is.na(data_by_state[column_number])
data_by_state_clean <- data_by_state[!bad_rows, ]
## Let's sort by column_number, followed by Hospital.Name.
data_by_state_clean <- data_by_state_clean[ order(data_by_state_clean[,column_number], data_by_state_clean$Hospital.Name), ]
row_number = num
if (row_number == "best")
row_number = 1
else if (row_number == "worst")
row_number = nrow(data_by_state_clean)
## if we are asking for a row that is out or range, return NA.
if (nrow(data_by_state_clean) < row_number){
NA
return
}
data_by_state_clean[row_number, data_by_state_clean$Hospital.Name]
## What is the lowest value?
##lowest_value <- as.numeric(mapply(min, data_by_state_clean[column_number]))
##data_lowest_value <- data_by_state_clean[data_by_state_clean[column_number] == lowest_value, ]
## TODO!  Need to sort and show the least alphabetical!
## Pull out the row that has the lowest value.
##data_min <- lapply(data_by_state_clean, min)
## Return hospital name in that state with lowest 30-day death
##data_lowest_value$Hospital.Name
## rate
}
source("rankhospital.R")
rankhospital("TX", "heart failure", 4)
View(data_by_state_clean)
foo <- data_by_state_clean[row_number,]
View(foo)
foo <- data_by_state[row_number, Hospital.Name]
foo <- data_by_state[row_number, data_by_state_clean$Hospital.Name]
foo <- data_by_state[row_number, 2]
rankhospital <- function(state, outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## Return hospital name in that state with the given rank
## 30-day death rate
## Read outcome data
data_all <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Check that state is valid
## Logic for validity: if it is in the table.
data_by_state <- data_all[data_all$State == state, ]
if (nrow(data_by_state) == 0){
stop("invalid state")
}
## Check that outcome are valid, and get further subset.
column_number <- -1
if (outcome == "heart attack"){
column_number <- 11
}
else if (outcome == "heart failure"){
column_number <- 17
}
else if (outcome == "pneumonia"){
column_number <- 23
}
else{
stop("invalid outcome")
}
## What is the column number for Hospital.Name?
column_number_hospital_name <- 2
## convert the right column to numbers.
data_by_state[, column_number] <- as.numeric(data_by_state[, column_number])
## Let's remove the NA's.
bad_rows <- is.na(data_by_state[column_number])
data_by_state_clean <- data_by_state[!bad_rows, ]
## Let's sort by column_number, followed by Hospital.Name.
data_by_state_clean <- data_by_state_clean[ order(data_by_state_clean[,column_number], data_by_state_clean$Hospital.Name), ]
row_number = num
if (row_number == "best")
row_number = 1
else if (row_number == "worst")
row_number = nrow(data_by_state_clean)
## if we are asking for a row that is out or range, return NA.
if (nrow(data_by_state_clean) < row_number){
NA
return
}
data_by_state_clean[row_number, column_number_hospital_name]
}
source("rankhospital.R")
rankhospital("TX", "heart failure", 4)
rankhospital("MD", "heart attack", "worst")
rankhospital("MN", "heart attack", 5000)
source"rankhospital.R"
source("rankhospital.R")
rankhospital("MD", "heart attack", "best")
rankhospital("MD", "heart attack", "workst")
rankhospital("MD", "heart attack", "worst")
rankhospital("MN", "heart attack", 5000)
best <- function(state, outcome) {
## Read outcome data
data_all <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Check that state is valid
## Logic for validity: if it is in the table.
data_by_state <- data_all[data_all$State == state, ]
if (nrow(data_by_state) == 0){
stop("invalid state")
}
## Check that outcome are valid, and get further subset.
column_number <- -1
if (outcome == "heart attack"){
column_number <- 11
}
else if (outcome == "heart failure"){
column_number <- 17
}
else if (outcome == "pneumonia"){
column_number <- 23
}
else{
stop("invalid outcome")
}
## What is the column number for Hospital.Name?
column_number_hospital_name <- 2
## convert the right column to numbers.
data_by_state[, column_number] <- as.numeric(data_by_state[, column_number])
## Let's remove the NA's.
bad_rows <- is.na(data_by_state[column_number])
data_by_state <- data_by_state[!bad_rows, ]
## Let's sort by column_number, followed by Hospital.Name.
data_by_state <- data_by_state[ order(data_by_state[,column_number], data_by_state$Hospital.Name), ]
data_by_state[1, column_number_hospital_name]
## What is the lowest value?
##lowest_value <- as.numeric(mapply(min, data_by_state_clean[column_number]))
##data_lowest_value <- data_by_state_clean[data_by_state_clean[column_number] == lowest_value, ]
## TODO!  Need to sort and show the least alphabetical!
## Pull out the row that has the lowest value.
##data_min <- lapply(data_by_state_clean, min)
## Return hospital name in that state with lowest 30-day death
## data_lowest_value$Hospital.Name
## rate
}
source("best.R")
best("TX", "heart attack")
best("TX", "heart failure")
best("MD", "heart attack")
best ("BB", "heart attack")
best("NY, "hert attack)
best("NY", "hert attack)
best("NY", "hert attack")
? split
rankall <- function(outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## For each state, find the hospital of the given rank
## Return a data frame with the hospital names and the
## (abbreviated) state name
## Read outcome data
data_all <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Check that state is valid
## Logic for validity: if it is in the table.
##data_by_state <- data_all[data_all$State == state, ]
##if (nrow(data_by_state) == 0){
##  stop("invalid state")
##}
## Check that outcome are valid, and get further subset.
column_number <- -1
if (outcome == "heart attack"){
column_number <- 11
}
else if (outcome == "heart failure"){
column_number <- 17
}
else if (outcome == "pneumonia"){
column_number <- 23
}
else{
stop("invalid outcome")
}
## What is the column number for Hospital.Name?
column_number_hospital_name <- 2
## convert the right column to numbers.
##data_by_state[, column_number] <- as.numeric(data_by_state[, column_number])
data_all[, column_number] <- as.numeric(data_all[, column_number])
## Let's remove the NA's.
bad_rows <- is.na(data_all[column_number])
data_all <- data_all[!bad_rows, ]
## Let's sort by column_number, followed by Hospital.Name.
data_all <- data_all[ order(data_all[,column_number], data_all$Hospital.Name), ]
row_number = num
if (row_number == "best")
row_number = 1
else if (row_number == "worst")
row_number = nrow(data_all)
## if we are asking for a row that is out or range, return NA.
if (nrow(data_all) < row_number){
NA
return
}
## Let's return the correct row, and the correct column.
data_all[row_number, column_number_hospital_name]
}
source("rankall.R")
rankall("heart attack", 20)
foo <- by(data_all, data_all$State, min)
foo <- by(data_all, data_all$state, function(x) data_all[1,])
foo <- by(data_all, data_all$state, function(x) data_all[1])
foo <- by(data_all, data_all$state, function(x) data_all[1,1])
foo <- by(data_all, data_all$state, summary)
foo <- by(data_all, data_all[,"State"], summary)
foo <- by(data_all, data_all[,"State"], min)
foo <- by(data_all, data_all[,"State"], function(x) data_all[1,1])
foo <- by(data_all, data_all[,"State"], function(x) data_all[x,1])
foo <- split(data_all, data_all[,"State"])
bar <- lapply(foo, min)
bar <- lapply(foo[, column_number], min)
bar <- lapply(foo[,, column_number], min)
bar <- lapply(foo[column_number], min)
foo2 <- split(data_all, data_all$State)
foo3 <- lapply(foo2, function(myfunc) myfunc[1,])
myfunc <- function(myDataSet, rowNumber){myfunc[rowNumber,]}
foo4 <- lapply(foo2, myfunc(1))
rowNumber <- 1
foo4 <- lapply(foo2, myfunc)
myfunc <- function(myDataSet){myfunc[rowNumber,]}
foo4 <- lapply(foo2, myfunc)
myfunc <- function(myDataSet)myDataSet[rowNumber,]
foo4 <- lapply(foo2, myfunc)
rankall <- function(outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## For each state, find the hospital of the given rank
## Return a data frame with the hospital names and the
## (abbreviated) state name
## Read outcome data
data_all <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Check that state is valid
## Logic for validity: if it is in the table.
##data_by_state <- data_all[data_all$State == state, ]
##if (nrow(data_by_state) == 0){
##  stop("invalid state")
##}
## Check that outcome are valid, and get further subset.
column_number <- -1
if (outcome == "heart attack"){
column_number <- 11
}
else if (outcome == "heart failure"){
column_number <- 17
}
else if (outcome == "pneumonia"){
column_number <- 23
}
else{
stop("invalid outcome")
}
## What is the column number for Hospital.Name?
column_number_hospital_name <- 2
## convert the right column to numbers.
##data_by_state[, column_number] <- as.numeric(data_by_state[, column_number])
data_all[, column_number] <- as.numeric(data_all[, column_number])
## Let's remove the NA's.
bad_rows <- is.na(data_all[column_number])
data_all <- data_all[!bad_rows, ]
## Let's sort by column_number, followed by Hospital.Name.
data_all <- data_all[ order(data_all[,column_number], data_all$Hospital.Name), ]
#   row_number = num
#   if (row_number == "best")
#     row_number = 1
#   else if (row_number == "worst")
#     row_number = nrow(data_all)
## if we are asking for a row that is out or range, return NA.
if (nrow(data_all) < row_number){
NA
return
}
## let's split the dataset into different states.
data_split <- split(data_all, data_all$State)
## Let's create a function that can be applied to each group
## and return the right row.
get_row <- function(myDataSet){
row_number = num
if (row_number == "best")
row_number = 1
else if (row_number == "worst")
row_number = nrow(myDataSet)
myDataSet[row_number,]
}
## Let's return the collection of correct rows.
data_output <- lapply(data_split, get_row)
## Let's return the correct row, and the correct column.
##data_all[row_number, column_number_hospital_name]
}
source("rankall.R")
head(rankall("heart attack", 20), 10)
source("rankall.R")
source("rankall.R")
head(rankall("heart attack", 20), 10)
head(rankall("heart attack", 20), 10)
source("rankall.R")
head(rankall("heart attack", 20), 10)
source("rankall.R")
head(rankall("heart attack", 20), 10)
head(rankall("heart attack", 20), 10)
foo <- data_output[[1,2,3],]
foo <- data_output[1,]
foo <- data.frame(hospital=unlist(data_output),state=names(data_output))
View(foo)
rankall <- function(outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## For each state, find the hospital of the given rank
## Return a data frame with the hospital names and the
## (abbreviated) state name
## Read outcome data
data_all <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Check that state is valid
## Logic for validity: if it is in the table.
##data_by_state <- data_all[data_all$State == state, ]
##if (nrow(data_by_state) == 0){
##  stop("invalid state")
##}
## Check that outcome are valid, and get further subset.
column_number <- -1
if (outcome == "heart attack"){
column_number <- 11
}
else if (outcome == "heart failure"){
column_number <- 17
}
else if (outcome == "pneumonia"){
column_number <- 23
}
else{
stop("invalid outcome")
}
## What is the column number for Hospital.Name?
column_number_hospital_name <- 2
## convert the right column to numbers.
##data_by_state[, column_number] <- as.numeric(data_by_state[, column_number])
data_all[, column_number] <- as.numeric(data_all[, column_number])
## Let's remove the NA's.
bad_rows <- is.na(data_all[column_number])
data_all <- data_all[!bad_rows, ]
## Let's sort by column_number, followed by Hospital.Name.
data_all <- data_all[ order(data_all[,column_number], data_all$Hospital.Name), ]
#   row_number = num
#   if (row_number == "best")
#     row_number = 1
#   else if (row_number == "worst")
#     row_number = nrow(data_all)
#   ## if we are asking for a row that is out or range, return NA.
#   if (nrow(data_all) < row_number){
#     NA
#     return
#   }
## let's split the dataset into different states.
data_split <- split(data_all, data_all$State)
## Let's create a function that can be applied to each group
## and return the right row.
get_row <- function(myDataSet){
row_number = num
if (row_number == "best")
row_number = 1
else if (row_number == "worst")
row_number = nrow(myDataSet)
if (nrow(data_all) < row_number){
NA
return
}
myDataSet[row_number,]
}
## Let's return the collection of correct rows.
data_output <- lapply(data_split, get_row)
## let's create a dataframe with the right data.
data_output2 <- data.frame(hospital=unlist(data_output), state=names(data_output))
x <- 5
## Let's return the correct row, and the correct column.
##data_all[row_number, column_number_hospital_name]
}
source("rankall.R")
head(rankall("heart attack", 1), 10)
source("rankall.R")
head(rankall("heart attack", 1), 10)
head(rankall("heart attack", 1), 10)
rankall <- function(outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## For each state, find the hospital of the given rank
## Return a data frame with the hospital names and the
## (abbreviated) state name
## Read outcome data
data_all <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Check that state is valid
## Logic for validity: if it is in the table.
##data_by_state <- data_all[data_all$State == state, ]
##if (nrow(data_by_state) == 0){
##  stop("invalid state")
##}
## Check that outcome are valid, and get further subset.
column_number <- -1
if (outcome == "heart attack"){
column_number <- 11
}
else if (outcome == "heart failure"){
column_number <- 17
}
else if (outcome == "pneumonia"){
column_number <- 23
}
else{
stop("invalid outcome")
}
## What is the column number for Hospital.Name?
column_number_hospital_name <- 2
## convert the right column to numbers.
##data_by_state[, column_number] <- as.numeric(data_by_state[, column_number])
data_all[, column_number] <- as.numeric(data_all[, column_number])
## Let's remove the NA's.
bad_rows <- is.na(data_all[column_number])
data_all <- data_all[!bad_rows, ]
## Let's sort by column_number, followed by Hospital.Name.
data_all <- data_all[ order(data_all[,column_number], data_all$Hospital.Name), ]
#   row_number = num
#   if (row_number == "best")
#     row_number = 1
#   else if (row_number == "worst")
#     row_number = nrow(data_all)
#   ## if we are asking for a row that is out or range, return NA.
#   if (nrow(data_all) < row_number){
#     NA
#     return
#   }
## let's split the dataset into different states.
data_split <- split(data_all, data_all$State)
## Let's create a function that can be applied to each group
## and return the right row.
get_row <- function(myDataSet){
row_number = num
if (row_number == "best")
row_number = 1
else if (row_number == "worst")
row_number = nrow(myDataSet)
if (nrow(data_all) < row_number){
NA
return
}
myDataSet[row_number, myDataSet[column_number_hospital_name]]
myDataSet
}
## Let's return the collection of correct rows.
data_output <- lapply(data_split, get_row)
## let's create a dataframe with the right data.
data_output2 <- data.frame(hospital=unlist(data_output), state=names(data_output))
data_output2
## Let's return the correct row, and the correct column.
##data_all[row_number, column_number_hospital_name]
}
source("rankall.R")
head(rankall("heart attack", 1), 10)
source("rankall.R")
head(rankall("heart attack", 1), 10)
head(rankall("heart attack", 1), 10)
View(myDataSet)
source("rankall.R")
head(rankall("heart attack", 1), 10)
head(rankall("heart attack", 20), 10)
tail(rankall("pneumonia", "worst"), 3)
tail(rankall("heart failure"), 10)
source("rankall.R")
tail(rankall("heart failure"), 10)
source("rankall.R")
tail(rankall("pneumonia", "worst"), 3)
head(rankall("heart attack", 20), 10)
head(rankall("heart attack", 20), 10)
